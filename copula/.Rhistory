# vmar_data = convert2marginal(map[1,], vmar$pars[[vmar$idbest]], vmar$distnames[vmar$idbest])
# hmar_data = convert2marginal(xp[1,], hmar$pars[[hmar$idbest]], hmar$distnames[hmar$idbest])
# dmar_data = convert2marginal(xp[2,], dmar$pars[[dmar$idbest]], dmar$distnames[dmar$idbest])
#### compute copula by vegmap
# savename = './copula_spatial_0413.RData'
# compute_spatial(vmar_data, hmar_data, dmar_data, savename)
# load(savename)
savename = './copula_spatial_xyz.RData'
compute_xyz_spatial(map[1,], xp, mts, vmar$distnames[vmar$idbest], hmar$distnames[hmar$idbest], dmar$distnames[dmar$idbest], savename)
load(savename)
compute_spatial_old <- function(d1, savename){
### compute conditional prob
library(akima)
library(fields)
################ compute marginal
nmts = length(mts)
cvine = d0 = d1 = veg1 = heat1 = dry1 = matrix(list(), 6,nmts)
for (vegi in 1:6){
for (mi in 1:length(mts)){
print(sprintf('%d,%d', vegi, mi))
## fit cvine
ff = as.matrix(d1[[vegi, mi]])
cvine[[vegi, mi]]<-CDVineCondFit(ff,Nx=2,c(1,2,3,4,5,9),rotation=F,treecrit="AIC",type="CVine",selectioncrit="AIC")
}
}
save(cvine, file = savename)
}
savename = './copula_spatial_cvine.RData'
compute_xyz_spatial(d1, savename)
savename = './copula_spatial_cvine.RData'
compute_xyz_spatial(d1, savename)
compute_spatial_old <- function(d1, savename){
### compute conditional prob
library(akima)
library(fields)
################ compute marginal
nmts = dim(d1)[2]
cvine = matrix(list(), 6,nmts)
for (vegi in 1:6){
for (mi in 1:length(mts)){
print(sprintf('%d,%d', vegi, mi))
## fit cvine
ff = as.matrix(d1[[vegi, mi]])
cvine[[vegi, mi]]<-CDVineCondFit(ff,Nx=2,c(1,2,3,4,5,9),rotation=F,treecrit="AIC",type="CVine",selectioncrit="AIC")
}
}
save(cvine, file = savename)
}
savename = './copula_spatial_cvine.RData'
compute_xyz_spatial(d1, savename)
compute_spatial_old <- function(d1, savename){
### compute conditional prob
library(akima)
library(fields)
################ compute marginal
nmts = dim(d1)[2]
cvine = matrix(list(), 6,nmts)
for (vegi in 1:6){
for (mi in 1:nmts){
print(sprintf('%d,%d', vegi, mi))
## fit cvine
ff = as.matrix(d1[[vegi, mi]])
cvine[[vegi, mi]]<-CDVineCondFit(ff,Nx=2,c(1,2,3,4,5,9),rotation=F,treecrit="AIC",type="CVine",selectioncrit="AIC")
}
}
save(cvine, file = savename)
}
savename = './copula_spatial_cvine.RData'
compute_xyz_spatial(d1, savename)
compute_spatial_old <- function(d1, savename){
### compute conditional prob
library(akima)
library(fields)
################ compute marginal
nmts = dim(d1)[2]
cvine = matrix(list(), 6,nmts)
for (vegi in 1:6){
for (mi in 1:nmts){
print(sprintf('%d,%d', vegi, mi))
## fit cvine
ff = as.matrix(d1[[vegi, mi]])
cvine[[vegi, mi]]<-CDVineCondFit(ff,Nx=2,c(1,2,3,4,5,9),rotation=F,treecrit="AIC",type="CVine",selectioncrit="AIC")
}
}
save(cvine, file = savename)
}
compute_spatial_old(d1, savename)
#
plt_3d_copula <- function(td1){
library(plotly)
fig <- plot_ly(td1, x = ~H, y = ~D, z = ~gpp,
marker = list(color = ~gpp, colorscale = c('#FFE1A1', '#683531'), showscale = TRUE))
fig <- fig %>% add_markers()
fig <- fig %>% layout(scene = list(xaxis = list(title = 'heat'),
yaxis = list(title = 'drought'),
zaxis = list(title = 'gpp')),
annotations = list(
x = 1.13,
y = 1.05,
text = 'GPP',
xref = 'paper',
yref = 'paper',
showarrow = FALSE
))
fig
}
load(savename)
savename = './copula_spatial_simu.RData'
cvine[[]]cvine[[vegi, mi]]$Matrix
cvine[[vegi, mi]]$Matrix
cvine[[vegi, mi]]$Matrix
d<-dim(cvine[[vegi, mi]]$Matrix)[1]
cond1<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-1,(d+1)-1]]
cond2<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-2,(d+1)-2]]
condition<-cbind(cond1,cond2)# create conditional distribution matrix#
condition
cvine[[vegi, mi]]$Matrix
ff
d1
simulate_spatial <- function(d1, cvine, savename){nmts = dim(d1)[2]
d2 = matrix(list(), 6,nmts)
for (vegi in 1:6){
for (mi in 1:nmts){
print(sprintf('%d,%d', vegi, mi))
d<-dim(cvine[[vegi, mi]]$Matrix)[1]
ff = d1[[vegi, mi]]
cond1<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-1,(d+1)-1]]
cond2<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-2,(d+1)-2]]
condition<-cbind(cond1,cond2)# create conditional distribution matrix#
f1<-CDVineCondSim(cvine,condition)
f1 = data.frame(f1)
names(f1) = names(ff)
d2[[vegi, mi]] = f1
}
}
save(d2, file = savename)
return(d2)
}
savename = './copula_spatial_simu.RData'
simulate_spatial(d1, cvine, savename)
d1
cvine
simulate_spatial <- function(d1, cvine, savename){
nmts = dim(d1)[2]
d2 = matrix(list(), 6,nmts)
for (vegi in 1:6){
for (mi in 1:nmts){
print(sprintf('%d,%d', vegi, mi))
d<-dim(cvine[[vegi, mi]]$Matrix)[1]
ff = d1[[vegi, mi]]
cond1<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-1,(d+1)-1]]
cond2<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-2,(d+1)-2]]
condition<-cbind(cond1,cond2)# create conditional distribution matrix#
f1<-CDVineCondSim(cvine,condition)
f1 = data.frame(f1)
names(f1) = names(ff)
d2[[vegi, mi]] = f1
}
}
save(d2, file = savename)
return(d2)
}
simulate_spatial(d1, cvine, savename)
nmts = dim(d1)[2]
d2 = matrix(list(), 6,nmts)
for (vegi in 1:6){
for (mi in 1:nmts){
print(sprintf('%d,%d', vegi, mi))
d<-dim(cvine[[vegi, mi]]$Matrix)[1]
ff = d1[[vegi, mi]]
cond1<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-1,(d+1)-1]]
cond2<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-2,(d+1)-2]]
condition<-cbind(cond1,cond2)# create conditional distribution matrix#
f1<-CDVineCondSim(cvine,condition)
f1 = data.frame(f1)
names(f1) = names(ff)
d2[[vegi, mi]] = f1
}
}
print(sprintf('%d,%d', vegi, mi))
d<-dim(cvine[[vegi, mi]]$Matrix)[1]
ff = d1[[vegi, mi]]
cond1<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-1,(d+1)-1]]
cond2<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-2,(d+1)-2]]
condition<-cbind(cond1,cond2)# create conditional distribution matrix#
condition
cvine
simulate_spatial <- function(d1, cvine, savename){
nmts = dim(d1)[2]
d2 = matrix(list(), 6,nmts)
for (vegi in 1:6){
for (mi in 1:nmts){
print(sprintf('%d,%d', vegi, mi))
d<-dim(cvine[[vegi, mi]]$Matrix)[1]
ff = d1[[vegi, mi]]
cond1<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-1,(d+1)-1]]
cond2<-ff[,cvine[[vegi, mi]]$Matrix[(d+1)-2,(d+1)-2]]
condition<-cbind(cond1,cond2)# create conditional distribution matrix#
f1<-CDVineCondSim(cvine[[vegi, mi]],condition)
f1 = data.frame(f1)
names(f1) = names(ff)
d2[[vegi, mi]] = f1
}
}
save(d2, file = savename)
return(d2)
}
savename = './copula_spatial_simu.RData'
simulate_spatial(d1, cvine, savename)
load(savename)
d2
d1
#
plt_3d_copula <- function(td1){
library(plotly)
fig <- plot_ly(td1, x = ~H, y = ~D, z = ~gpp,
marker = list(color = ~gpp, colorscale = c('#FFE1A1', '#683531'), showscale = TRUE))
fig <- fig %>% add_markers()
fig <- fig %>% layout(scene = list(xaxis = list(title = 'heat'),
yaxis = list(title = 'drought'),
zaxis = list(title = 'gpp')),
annotations = list(
x = 1.13,
y = 1.05,
text = 'GPP',
xref = 'paper',
yref = 'paper',
showarrow = FALSE
))
fig
}
plt_3d_copula(d2[[1,1]])
plt_3d_copula(d2[[6,4]])
plt_3d_copula(d1[[6,4]])
plt_3d_copula(d2[[6,4]])
plt_3d_copula(d2[[1,4]])
plt_3d_copula(d1[[1,4]])
d1[[1,4]]$H
hist(d1[[1,4]]$H)
hist(d1[[1,4]]$H,100)
hist(d1[[1,4]]$H,1000)
hmar$distnames[hmar$idbest]
xp
max(gp[[1,4]])
max(xp[[1,4]])
max(xp[[1,4]],na.rm =T)
mean(xp[[1,4]],na.rm =T)
hist(xp[[1,4]],na.rm =T)
hist(xp[[1,4]],na.rm =T)
vegi = 1
idx = vegmap == vegi
mi = 4
theat = xp[[1, mi]][idx]
hist(theat)
hist(theat)
idx
theat = xp[[1, mi]][idx]
hist(theat)
a = MT_copula_marginal(theat, 'gev')
a = MT_copula_marginal(theat, c("gev"))
theat
idx = vegmap == vegi
theat = xp[[mi]][idx]
xp
xp[[1,mi]]
theat = xp[[1,mi]][idx]
theat
mean(is.na(theat))
image(idx)
idx
idx
idx = vegmap == vegi
tveg = map[[mi]][idx]
theat = xp[[mi]][idx]
tdry = yp[[mi]][idx]
td = data.frame(gpp = tveg, H = theat, D = tdry)
td = td[colMeans(t(is.na(td))) == 0,]
theat = xp[[1,mi]][idx]
tdry = xp[[2,mi]][idx]
td = data.frame(gpp = tveg, H = theat, D = tdry)
td = td[colMeans(t(is.na(td))) == 0,]
d1[[vegi, mi]] = td
td
idx = vegmap == vegi
tveg = map[[mi]][idx]
theat = xp[[1, mi]][idx]
tdry = xp[[2, mi]][idx]
td = data.frame(gpp = tveg, H = theat, D = tdry)
td = td[colMeans(t(is.na(td))) == 0,]
d0[[vegi, mi]] = td
a = MT_copula_marginal(td$H, nmh)
nmh
a
plot(a)
plot(a$fits[[1]])
a = MT_copula_marginal(td$H, 'norm')
a
plot(a$fits[[1]])
a =  MT_copula_marginal(td$H)
a$idbest
a$distnames
plot(a$fits[[2]])
## old codes
compute_xyz_spatial <- function(map, xp, mts, nmgpp, nmh, nmd, savename){
### compute conditional prob
library(akima)
library(fields)
################ compute marginal
nmts = length(mts)
cvine = d0 = d1 = veg1 = heat1 = dry1 = matrix(list(), 6,nmts)
for (vegi in 1:6){
for (mi in 1:length(mts)){
print(sprintf('%d,%d', vegi, mi))
idx = vegmap == vegi
tveg = map[[mi]][idx]
theat = xp[[1, mi]][idx]
tdry = xp[[2, mi]][idx]
td = data.frame(gpp = tveg, H = theat, D = tdry)
td = td[colMeans(t(is.na(td))) == 0,]
d0[[vegi, mi]] = td
## compute marginal
veg1[[vegi, mi]] = MT_copula_marginal(td$gpp)
heat1[[vegi, mi]] = MT_copula_marginal(td$H)
dry1[[vegi, mi]] = MT_copula_marginal(td$D, c(1,5,6))
d1[[vegi, mi]] = data.frame(gpp = veg1[[vegi, mi]]$x, H = heat1[[vegi, mi]]$x, D = dry1[[vegi, mi]]$x)
}
}
out = list()
out$d1 = d1
out$dry1 = dry1
out$heat1 = heat1
out$veg1 = veg1
save(d1, dry1, veg1, heat1, file = savename)
}
#### get marginals
# vmar_data = convert2marginal(map[1,], vmar$pars[[vmar$idbest]], vmar$distnames[vmar$idbest])
# hmar_data = convert2marginal(xp[1,], hmar$pars[[hmar$idbest]], hmar$distnames[hmar$idbest])
# dmar_data = convert2marginal(xp[2,], dmar$pars[[dmar$idbest]], dmar$distnames[dmar$idbest])
#### compute copula by vegmap
# savename = './copula_spatial_0413.RData'
# compute_spatial(vmar_data, hmar_data, dmar_data, savename)
# load(savename)
savename = './copula_spatial_xyz.RData'
compute_xyz_spatial(map[1,], xp, mts, vmar$distnames[vmar$idbest], hmar$distnames[hmar$idbest], dmar$distnames[dmar$idbest], savename)
load(savename)
d1
## old codes
compute_xyz_spatial <- function(map, xp, mts, nmgpp, nmh, nmd, savename){
### compute conditional prob
library(akima)
library(fields)
################ compute marginal
nmts = length(mts)
d0 = d1 = veg1 = heat1 = dry1 = matrix(list(), 6,nmts)
for (vegi in 1:6){
for (mi in 1:length(mts)){
print(sprintf('%d,%d', vegi, mi))
idx = vegmap == vegi
tveg = map[[mi]][idx]
theat = xp[[1, mi]][idx]
tdry = xp[[2, mi]][idx]
td = data.frame(gpp = tveg, H = theat, D = tdry)
td = td[colMeans(t(is.na(td))) == 0,]
d0[[vegi, mi]] = td
## compute marginal
veg1[[vegi, mi]] = MT_copula_marginal(td$gpp)
heat1[[vegi, mi]] = MT_copula_marginal(td$H)
dry1[[vegi, mi]] = MT_copula_marginal(td$D, c(1,5,6))
d1[[vegi, mi]] = data.frame(gpp = veg1[[vegi, mi]]$x, H = heat1[[vegi, mi]]$x, D = dry1[[vegi, mi]]$x)
}
}
out = list()
out$d0 = d0
out$d1 = d1
out$dry1 = dry1
out$heat1 = heat1
out$veg1 = veg1
save(d0, d1, dry1, veg1, heat1, file = savename)
}
#### get marginals
# vmar_data = convert2marginal(map[1,], vmar$pars[[vmar$idbest]], vmar$distnames[vmar$idbest])
# hmar_data = convert2marginal(xp[1,], hmar$pars[[hmar$idbest]], hmar$distnames[hmar$idbest])
# dmar_data = convert2marginal(xp[2,], dmar$pars[[dmar$idbest]], dmar$distnames[dmar$idbest])
#### compute copula by vegmap
# savename = './copula_spatial_0413.RData'
# compute_spatial(vmar_data, hmar_data, dmar_data, savename)
# load(savename)
savename = './copula_spatial_xyz.RData'
compute_xyz_spatial(map[1,], xp, mts, vmar$distnames[vmar$idbest], hmar$distnames[hmar$idbest], dmar$distnames[dmar$idbest], savename)
load(savename)
veg
d0
veg = d0[[1,1]]
vmarx = d1[[1,1]]
qqplot(ecdf(veg)(veg), vmarx, xlab = "Empirical quantile", ylab = "Theoretical quantile", main = "GPP",
cex.axis = 1, cex.lab = 1.5, cex.main = 2)
ecdf(veg)(veg)
veg
veg = d0[[1,1]]$gpp
vmarx = d1[[1,1]]$gpp
qqplot(ecdf(veg)(veg), vmarx, xlab = "Empirical quantile", ylab = "Theoretical quantile", main = "GPP",
cex.axis = 1, cex.lab = 1.5, cex.main = 2)
veg = h = d = vmarx = hmarx = dmarx = c()
for (vegi in 1:6){
for (mi in 1:5){
veg = c(veg, d0[[vegi,mi]]$gpp)
vmarx = c(vmarx, d1[[vegi,mi]]$gpp)
h = c(h, d0[[vegi,mi]]$H)
hmarx = c(hmarx, d1[[vegi,mi]]$H)
d = c(d, d0[[vegi,mi]]$D)
dmarx = c(dmarx, d1[[vegi,mi]]$D)
}
}
{
WD = 1920
HT = 700
jpeg("./figs/qqplot.jpg", width = WD, height = HT)
W_figure(1,3)
# plot(vmar$fits[[idv]])
par(cex = 1.5)
par(mar =  c(8.1, 7.1, 7.1, 2.1))
veg = h = d = vmarx = hmarx = dmarx = c()
for (vegi in 1:6){
for (mi in 1:5){
veg = c(veg, d0[[vegi,mi]]$gpp)
vmarx = c(vmarx, d1[[vegi,mi]]$gpp)
h = c(h, d0[[vegi,mi]]$H)
hmarx = c(hmarx, d1[[vegi,mi]]$H)
d = c(d, d0[[vegi,mi]]$D)
dmarx = c(dmarx, d1[[vegi,mi]]$D)
}
}
qqplot(ecdf(veg)(veg), vmarx, xlab = "Empirical quantile", ylab = "Theoretical quantile", main = "GPP",
cex.axis = 1, cex.lab = 1.5, cex.main = 2)
# dev.off()
# jpeg("./figs/qqplot_h.jpg", width = WD, height = HT)
par(mar =  c(8.1, 7.1, 7.1, 2.1))
qqplot(ecdf(h)(h), hmarx, xlab = "Empirical quantile", ylab = "Theoretical quantile", main = "Tmax",
cex.axis = 1, cex.lab = 1.5, cex.main = 2)
# plot(hmar$fits[[idh]])
# dev.off()
# jpeg("./figs/qqplot_d.jpg", width = WD, height = HT)
par(mar =  c(8.1, 7.1, 7.1, 2.1))
qqplot(ecdf(d)(d), dmarx, xlab = "Empirical quantile", ylab = "Theoretical quantile", main = "P-PET",
cex.axis = 1, cex.lab = 1.5, cex.main = 2)
# plot(dmar$fits[[idd]])
dev.off()
}
{
WD = 1920
HT = 700
jpeg("./figs/qqplot.jpg", width = WD, height = HT)
W_figure(1,3)
# plot(vmar$fits[[idv]])
par(cex = 1.5)
par(mar =  c(8.1, 7.1, 7.1, 2.1))
veg = h = d = vmarx = hmarx = dmarx = c()
for (vegi in 1:6){
for (mi in 1:5){
veg = c(veg, d0[[vegi,mi]]$gpp)
vmarx = c(vmarx, d1[[vegi,mi]]$gpp)
h = c(h, d0[[vegi,mi]]$H)
hmarx = c(hmarx, d1[[vegi,mi]]$H)
d = c(d, d0[[vegi,mi]]$D)
dmarx = c(dmarx, d1[[vegi,mi]]$D)
}
}
qqplot(vmarx, ecdf(veg)(veg), ylab = "Empirical quantile", xlab = "Theoretical quantile", main = "GPP",
cex.axis = 1, cex.lab = 1.5, cex.main = 2)
# dev.off()
# jpeg("./figs/qqplot_h.jpg", width = WD, height = HT)
par(mar =  c(8.1, 7.1, 7.1, 2.1))
qqplot(hmarx, ecdf(h)(h), ylab = "Empirical quantile", xlab = "Theoretical quantile", main = "Tmax",
cex.axis = 1, cex.lab = 1.5, cex.main = 2)
# plot(hmar$fits[[idh]])
# dev.off()
# jpeg("./figs/qqplot_d.jpg", width = WD, height = HT)
par(mar =  c(8.1, 7.1, 7.1, 2.1))
qqplot(dmarx, ecdf(d)(d), ylab = "Empirical quantile", xlab = "Theoretical quantile", main = "P-PET",
cex.axis = 1, cex.lab = 1.5, cex.main = 2)
# plot(dmar$fits[[idd]])
dev.off()
}
### get 2-D
plt_3d_copula(d0[[1,1]])
### get 2-D
plt_3d_copula(d1[[1,1]])
### get 2-D
plt_3d_copula(d1[[1,4]])
### get 2-D
plt_3d_copula(d0[[1,4]])
arrayfun(function(x)x, cvine)
cvine
cvine[[1,1]]$family
cvine[[1,1]]$type
cvine[[1,1]]$names
cvine[[1,1]]$par
cvine[[1,1]]$par2
cvine[[1,1]]$CondDistr
gpp1[[1,1]]
veg1[[1,1,]]
veg1[[1,1]]
arrayfun(function(x)x$distnames[x$idbest], cvine)
arrayfun(function(x)x$distnames[x$idbest], veg1)
arrayfun(function(x)x$distnames[x$idbest], veg2)
arrayfun(function(x)x$distnames[x$idbest], heat1)
arrayfun(function(x)x$distnames[x$idbest], dry1)
rm(list = ls())
library(WangTools)
library(LuGPP)
library(pracma)
clc()
